üí° Key Concepts: Models & The Database
1. The Spreadsheet Analogy
To understand how Django stores data, compare a Model to a standard spreadsheet:

The Model Class: This is the entire Tab/Sheet (e.g., "Student Records").

The Attributes (Fields): These are the Column Headers (Name, Age, Email).

The Instance: This is a single Row of data representing one unique item.

2. Django ORM (Object-Relational Mapper)
The ORM is the "Translator" of the system.

How it works: You write Python; the ORM converts it to SQL.

The Benefit: You don't need to know database-specific languages to manage data. You can switch from SQLite to PostgreSQL or MySQL without changing your Python code.

3. Migrations: The Project Timeline
Migrations are like "Version Control" (Git) for your database structure.

makemigrations: This takes a "snapshot" of your models.py. It creates a file in the migrations/ folder that describes what changed.

migrate: This applies that snapshot to the actual database file (db.sqlite3).

Why use them? They allow multiple developers to keep their databases in sync. If you add a "Phone Number" field, your teammate just runs migrate to get the same update.

4. The __str__ Method
This is a "Magic Method" in Python that defines how an object is displayed in the Django Admin and the Python Console.


5. Data Integrity & Validation
Django Models do more than store data‚Äîthey protect it.

max_length: Limits how many characters can be entered.

default: Provides a value if the user leaves a field blank.

null=True / blank=True: Defines whether a field is optional or required.

üõ†Ô∏è Student Lab: Data Discovery
Task: Create a new model in models.py for a Product in a store.

Add fields for name, price, and stock_quantity.

Run the migration commands.

Register it in admin.py.

Go to the Admin Panel and try to save a product with a "Price" that is actually a "Word."

Observation: Notice how Django automatically blocks the save and shows an error. This is built-in Validation.
